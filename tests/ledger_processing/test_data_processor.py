import unittest
from unittest.mock import patch, MagicMock, call
import json
import os
from cryptography.fernet import Fernet, InvalidToken
import psycopg2 # For raising psycopg2.Error

# Add project root to sys.path to allow importing ledger_processing
import sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

from ledger_processing import data_processor

# Use the key generated by data_processor or a known test key
# For consistent testing, it's better to use a fixed key for tests.
# However, data_processor.ENCRYPTION_KEY is generated/loaded at module import.
# We can either mock data_processor.ENCRYPTION_KEY or use it as is.
# Let's use a dedicated test key for more predictable tests.
TEST_FERNET_KEY = Fernet.generate_key()
test_cipher_suite = Fernet(TEST_FERNET_KEY)

# Helper function to encrypt data for tests using the test key
def encrypt_with_test_key(data_dict):
    json_str = json.dumps(data_dict)
    encrypted_bytes = test_cipher_suite.encrypt(json_str.encode('utf-8'))
    return encrypted_bytes.decode('utf-8')

class TestEncryptionDecryption(unittest.TestCase):

    def setUp(self):
        # Patch the ENCRYPTION_KEY used by the data_processor module for these tests
        self.key_patcher = patch('ledger_processing.data_processor.ENCRYPTION_KEY', TEST_FERNET_KEY)
        self.cipher_patcher = patch('ledger_processing.data_processor.cipher_suite', test_cipher_suite)
        self.key_patcher.start()
        self.cipher_patcher.start()

    def tearDown(self):
        self.key_patcher.stop()
        self.cipher_patcher.stop()
        # Clean up the dummy secret.key if created by data_processor's generate_or_load_fernet_key
        if os.path.exists(data_processor.FERNET_KEY_FILE):
            # Check if it's the one from data_processor and not a test specific one
            # This is tricky because the module might have been imported already.
            # For safety, only remove if we are sure it's the dummy one.
            # Given we patched ENCRYPTION_KEY, the original load logic might still run on import.
            # A cleaner way would be to ensure data_processor doesn't auto-create files on import for tests.
            pass # Avoid deleting files in tests for now, can be handled by test setup/teardown scripts

    def test_encrypt_decrypt_symmetric(self):
        original_data = {"key": "value", "number": 123}
        encrypted_str = encrypt_with_test_key(original_data) # Uses our test key

        # Decrypt using the function from data_processor, which should now use the patched test key
        decrypted_data = data_processor.decrypt_data(encrypted_str)
        self.assertEqual(decrypted_data, original_data)

    def test_decrypt_invalid_token_string(self):
        invalid_encrypted_str = "this_is_not_a_valid_fernet_token"
        decrypted_data = data_processor.decrypt_data(invalid_encrypted_str)
        self.assertIsNone(decrypted_data, "Decryption of invalid token string should return None")

    def test_decrypt_corrupted_data(self):
        original_data = {"key": "value"}
        encrypted_str = encrypt_with_test_key(original_data)
        corrupted_encrypted_str = encrypted_str[:-5] + "XXXXX" # Corrupt the token

        decrypted_data = data_processor.decrypt_data(corrupted_encrypted_str)
        self.assertIsNone(decrypted_data, "Decryption of corrupted data should return None")

    def test_decrypt_wrong_key(self):
        original_data = {"key": "secret_message"}
        # Encrypt with test_cipher_suite (which data_processor is patched to use)
        encrypted_str_with_test_key = encrypt_with_test_key(original_data)

        # Now, create a different cipher suite for decryption attempt
        another_key = Fernet.generate_key()
        wrong_cipher_suite = Fernet(another_key)

        # Temporarily patch data_processor's cipher_suite to use the wrong key for this test case
        with patch('ledger_processing.data_processor.cipher_suite', wrong_cipher_suite):
            decrypted_data = data_processor.decrypt_data(encrypted_str_with_test_key)
            self.assertIsNone(decrypted_data, "Decryption with wrong key should return None or raise InvalidToken leading to None")


class TestValidation(unittest.TestCase):
    def test_validate_data_valid(self):
        valid_data = {
            "transaction_id_external": "TXN123",
            "amount": 100.50,
            "currency": "USD",
            "timestamp": "2023-01-01T12:00:00Z",
            "account_holder_name": "John Doe",
            "email": "john.doe@example.com"
        }
        self.assertTrue(data_processor.validate_data(valid_data))

    def test_validate_data_missing_key(self):
        invalid_data = {
            "amount": 100.50,
            "currency": "USD",
            # "transaction_id_external" is missing
            "timestamp": "2023-01-01T12:00:00Z",
            "account_holder_name": "John Doe",
            "email": "john.doe@example.com"
        }
        self.assertFalse(data_processor.validate_data(invalid_data))

    def test_validate_data_invalid_amount_type(self):
        invalid_data = {
            "transaction_id_external": "TXN123",
            "amount": "not_a_number", # Invalid type
            "currency": "USD",
            "timestamp": "2023-01-01T12:00:00Z",
            "account_holder_name": "John Doe",
            "email": "john.doe@example.com"
        }
        self.assertFalse(data_processor.validate_data(invalid_data))

    def test_validate_data_invalid_amount_value(self):
        invalid_data = {
            "transaction_id_external": "TXN123",
            "amount": -50, # Invalid value
            "currency": "USD",
            "timestamp": "2023-01-01T12:00:00Z",
            "account_holder_name": "John Doe",
            "email": "john.doe@example.com"
        }
        self.assertFalse(data_processor.validate_data(invalid_data))

    def test_validate_data_not_a_dict(self):
        self.assertFalse(data_processor.validate_data("just a string"))


class TestParsing(unittest.TestCase):
    def test_parse_data_valid(self):
        raw_data = {
            "transaction_id_external": "TXN456",
            "amount": 200.75,
            "currency": "EUR",
            "timestamp": "2023-02-01T10:00:00Z",
            "account_holder_name": "Jane Doe",
            "email": "jane.doe@example.com",
            "description": "Payment for services",
            "banknote_serials": ["SN001", "SN002"]
        }
        parsed_data = data_processor.parse_data(raw_data)
        self.assertIsNotNone(parsed_data)
        self.assertEqual(parsed_data["account_holder_name"], "Jane Doe")
        self.assertEqual(parsed_data["email"], "jane.doe@example.com")
        self.assertEqual(parsed_data["transaction_details"]["amount"], 200.75)
        self.assertEqual(parsed_data["transaction_details"]["currency"], "EUR")
        self.assertEqual(parsed_data["transaction_details"]["external_id"], "TXN456")
        self.assertIn("Payment for services", parsed_data["transaction_details"]["description"])
        self.assertEqual(parsed_data["banknote_serials"], ["SN001", "SN002"])
        self.assertIn("hashed_password", parsed_data) # Checks for placeholder

    def test_parse_data_minimal(self):
        raw_data = { # Only strictly required fields by current parse_data logic before defaults
            "account_holder_name": "Jane Doe",
            "email": "jane.doe@example.com",
            "amount": 1.0 # amount is used by transaction_details
        }
        parsed_data = data_processor.parse_data(raw_data)
        self.assertIsNotNone(parsed_data)
        self.assertEqual(parsed_data["account_holder_name"], "Jane Doe")
        self.assertEqual(parsed_data["transaction_details"]["currency"], "USD") # Default
        self.assertEqual(parsed_data["transaction_details"]["transaction_type"], "deposit") # Default


@patch('ledger_processing.data_processor.get_db_connection') # Mocks the function that returns a connection
class TestDataStorage(unittest.TestCase):

    def test_store_new_user_data(self, mock_get_db_connection):
        # Setup mock connection and cursor
        mock_conn = MagicMock()
        mock_cursor = MagicMock()
        mock_get_db_connection.return_value = mock_conn
        mock_conn.cursor.return_value = mock_cursor

        # Simulate new user: first fetchone (accounts lookup) returns None
        # Then RETURNING account_id, transaction_id
        mock_cursor.fetchone.side_effect = [None, ("new_account_uuid",), ("new_transaction_uuid",)]

        parsed_data = {
            "account_holder_name": "Test User",
            "email": "test.user@example.com",
            "hashed_password": "test_hash",
            "transaction_details": {
                "amount": 100.00,
                "currency": "USD",
                "transaction_type": "deposit",
                "description": "Test deposit",
            },
            "banknote_serials": ["SNT001", "SNT002"]
        }
        data_processor.store_data(parsed_data)

        # Assertions
        mock_get_db_connection.assert_called_once()
        mock_conn.cursor.assert_called_once()

        # Check accounts INSERT
        self.assertTrue(any("INSERT INTO accounts" in str(call_args) for call_args in mock_cursor.execute.call_args_list))
        self.assertTrue(any(parsed_data["account_holder_name"] in str(call_args) for call_args in mock_cursor.execute.call_args_list))

        # Check balances INSERT for new user
        self.assertTrue(any("INSERT INTO balances" in str(call_args) and "new_account_uuid" in str(call_args) for call_args in mock_cursor.execute.call_args_list))

        # Check transactions INSERT
        self.assertTrue(any("INSERT INTO transactions" in str(call_args) and "new_account_uuid" in str(call_args) for call_args in mock_cursor.execute.call_args_list))

        # Check balances UPDATE
        self.assertTrue(any("UPDATE balances SET balance = balance + %s" in str(call_args) for call_args in mock_cursor.execute.call_args_list))

        # Check serial_boxes INSERT
        self.assertEqual(mock_cursor.execute.call_args_list.count(
            call('INSERT INTO serial_boxes (serial_number, assigned_account_id, status, product_id)\n                VALUES (%s, %s, %s, %s);', ('SNT001', 'new_account_uuid', 'assigned', 'banknote'))
        ), 0) # Actual call might be slightly different due to formatted string in code. Let's check parts:
        self.assertTrue(any("INSERT INTO serial_boxes" in str(call_args) and "SNT001" in str(call_args) for call_args in mock_cursor.execute.call_args_list))
        self.assertTrue(any("INSERT INTO serial_boxes" in str(call_args) and "SNT002" in str(call_args) for call_args in mock_cursor.execute.call_args_list))

        mock_conn.commit.assert_called_once()
        mock_conn.rollback.assert_not_called()
        mock_cursor.close.assert_called_once()
        mock_conn.close.assert_called_once()

    def test_store_existing_user_data(self, mock_get_db_connection):
        mock_conn = MagicMock()
        mock_cursor = MagicMock()
        mock_get_db_connection.return_value = mock_conn
        mock_conn.cursor.return_value = mock_cursor

        # Simulate existing user: first fetchone returns existing account_id
        # Then RETURNING transaction_id
        mock_cursor.fetchone.side_effect = [("existing_account_uuid",), ("new_transaction_uuid",)]

        parsed_data = {
            "account_holder_name": "Existing User", # This won't be used for INSERT if user exists
            "email": "existing.user@example.com",
            "hashed_password": "existing_hash", # This won't be used
            "transaction_details": {
                "amount": 50.00,
                "currency": "EUR",
                "transaction_type": "deposit",
                "description": "Another deposit",
            },
            "banknote_serials": [] # No serials this time
        }
        data_processor.store_data(parsed_data)

        mock_get_db_connection.assert_called_once()

        # Check that accounts INSERT was NOT called with "Existing User"
        # The SELECT query for accounts is called.
        self.assertTrue(any("SELECT account_id FROM accounts WHERE email = %s;" in str(call_args) for call_args in mock_cursor.execute.call_args_list))
        # Check that INSERT INTO accounts for "Existing User" was not made
        # This is harder to check precisely without more complex mock_cursor.execute side_effect logic.
        # A simpler check: count how many times INSERT INTO accounts is present. It shouldn't be.
        # However, the code does not have a conditional INSERT, it just doesn't use the name if account exists.
        # The important part is that the existing account_id is used.

        # Check transactions INSERT uses existing_account_uuid
        self.assertTrue(any("INSERT INTO transactions" in str(call_args) and "existing_account_uuid" in str(call_args) for call_args in mock_cursor.execute.call_args_list))

        # Check balances UPDATE uses existing_account_uuid
        self.assertTrue(any("UPDATE balances SET balance = balance + %s" in str(call_args) and "existing_account_uuid" in str(call_args) for call_args in mock_cursor.execute.call_args_list))

        # Check serial_boxes INSERT was NOT called
        self.assertFalse(any("INSERT INTO serial_boxes" in str(call_args) for call_args in mock_cursor.execute.call_args_list))

        mock_conn.commit.assert_called_once()
        mock_conn.rollback.assert_not_called()

    def test_store_data_db_error_on_insert(self, mock_get_db_connection):
        mock_conn = MagicMock()
        mock_cursor = MagicMock()
        mock_get_db_connection.return_value = mock_conn
        mock_conn.cursor.return_value = mock_cursor

        # Simulate new user, then error on first INSERT (accounts)
        mock_cursor.fetchone.return_value = None # New user
        mock_cursor.execute.side_effect = [
            None, # for SELECT account_id
            psycopg2.Error("Simulated DB error on INSERT accounts") # Error on INSERT accounts
        ]
        # The first call to execute is the SELECT. The second is INSERT accounts.

        parsed_data = {
            "account_holder_name": "Error User",
            "email": "error.user@example.com",
            "hashed_password": "error_hash",
            "transaction_details": {"amount": 10.00, "currency": "USD", "transaction_type": "deposit"},
            "banknote_serials": []
        }
        data_processor.store_data(parsed_data) # Should catch the error

        mock_conn.commit.assert_not_called() # Commit should not be called on error
        mock_conn.rollback.assert_called_once() # Rollback should be called

    def test_store_data_db_error_on_update_balance(self, mock_get_db_connection):
        mock_conn = MagicMock()
        mock_cursor = MagicMock()
        mock_get_db_connection.return_value = mock_conn
        mock_conn.cursor.return_value = mock_cursor

        # Simulate existing user, success on transaction insert, error on balance update
        mock_cursor.fetchone.side_effect = [
            ("existing_account_uuid",), # SELECT account_id -> existing user
            ("new_transaction_uuid",)   # INSERT transactions RETURNING transaction_id
        ]

        def execute_side_effect(*args, **kwargs):
            sql = args[0]
            if "UPDATE balances" in sql:
                raise psycopg2.Error("Simulated DB error on UPDATE balances")
            return MagicMock() # Default for other execute calls

        mock_cursor.execute.side_effect = execute_side_effect

        parsed_data = {
            "account_holder_name": "Error User Balance",
            "email": "error.user.balance@example.com",
            "hashed_password": "error_hash",
            "transaction_details": {"amount": 20.00, "currency": "USD", "transaction_type": "deposit"},
            "banknote_serials": []
        }
        data_processor.store_data(parsed_data)

        mock_conn.commit.assert_not_called()
        mock_conn.rollback.assert_called_once()

if __name__ == '__main__':
    # This is to ensure data_processor's generate_or_load_fernet_key doesn't interfere if it creates 'secret.key'
    # A better solution is to make data_processor.py not have side effects on import.
    # For now, if 'secret.key' is created by the module import, remove it before tests if it's not the test key.
    # This is still a bit risky. Best to configure data_processor module to not auto-create.
    if os.path.exists(data_processor.FERNET_KEY_FILE):
        # This check is imperfect.
        # If we could guarantee FERNET_KEY_FILE is only created by the module under test's default path,
        # and not by some other process, then deleting it would be fine for test isolation.
        # For now, we'll leave it and rely on patching for encryption tests.
        pass

    unittest.main()
