"""
Placeholder script for interacting with the deployed VisaTopUp.sol smart contract.

Prerequisites:
1. Python 3.7+ installed.
2. Web3.py library installed (`pip install web3`).
3. Access to an Ethereum node (same one used for deployment, e.g., Ganache, Infura).
4. `deployment_info.json` file present in the same directory (generated by `deploy_visa_top_up.py`),
   containing the contract address and ABI.
5. Private keys for accounts that will interact with the contract (owner, authorized backend).

This script is a template and requires:
- Configuration of Ethereum node URL if different from deployment.
- Private keys for the owner and authorized backend accounts.
"""

import json
import os
import time
from web3 import Web3

# --- Configuration ---
# Load deployment information
try:
    with open("deployment_info.json", 'r') as f:
        deployment_info = json.load(f)
    CONTRACT_ADDRESS = deployment_info['contract_address']
    CONTRACT_ABI = deployment_info['abi']
    ETH_NODE_URL = deployment_info.get('network_url', "http://127.0.0.1:8545") # Use deployed network or fallback
except FileNotFoundError:
    print("Error: deployment_info.json not found. Please run deploy_visa_top_up.py first.")
    CONTRACT_ADDRESS = None
    CONTRACT_ABI = None
    ETH_NODE_URL = "http://127.0.0.1:8545" # Fallback
    # exit() # Or handle more gracefully

# Replace with your private keys (ensure they have 0x prefix)
# These accounts must exist and be funded on your Ethereum node (e.g., Ganache)
OWNER_PRIVATE_KEY = "YOUR_OWNER_PRIVATE_KEY_HERE" # Private key of the contract owner
BACKEND_PRIVATE_KEY = "YOUR_BACKEND_PRIVATE_KEY_HERE" # Private key for the authorized backend
USER_FOR_TOPUP_ADDRESS = "0x________________________________________" # A sample user address for testing top-up

GAS_LIMIT_INTERACTION = 500000  # Adjust as needed for function calls
GAS_PRICE_GWEI_INTERACTION = 10 # Adjust based on network conditions

def load_contract(w3, contract_address, contract_abi):
    """Loads the deployed contract instance."""
    if not contract_address or not contract_abi:
        print("Contract address or ABI not available. Cannot load contract.")
        return None
    try:
        contract = w3.eth.contract(address=contract_address, abi=contract_abi)
        print(f"Contract loaded successfully at address: {contract.address}")
        return contract
    except Exception as e:
        print(f"Error loading contract: {e}")
        return None

def send_transaction(w3, contract_function, sender_account, gas_limit, gas_price_gwei):
    """Helper function to build, sign, and send a transaction."""
    try:
        tx_params = {
            'from': sender_account.address,
            'gas': gas_limit,
            'gasPrice': w3.to_wei(gas_price_gwei, 'gwei'),
            'nonce': w3.eth.get_transaction_count(sender_account.address),
        }
        transaction = contract_function.build_transaction(tx_params)

        signed_tx = w3.eth.account.sign_transaction(transaction, private_key=sender_account.key)
        tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)

        print(f"Transaction sent. Tx hash: {tx_hash.hex()}")
        print("Waiting for transaction receipt...")
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash, timeout=180)
        print(f"Transaction successful. Block number: {tx_receipt.blockNumber}, Gas used: {tx_receipt.gasUsed}")
        return tx_receipt
    except Exception as e:
        print(f"Error sending transaction: {e}")
        if "revert" in str(e).lower() or "execution reverted" in str(e).lower() :
             # Try to get revert reason if available (ganache often provides it)
            try:
                # This is a bit of a hack, actual error parsing can be complex
                error_details = json.loads(str(e).split("{",1)[1].rsplit("}",1)[0])
                print(f"Revert reason: {error_details.get('message', 'N/A')}")
            except:
                 pass # Ignore if parsing fails
        return None

def main():
    """
    Main interaction function.
    """
    print("--- VisaTopUp Contract Interaction Script ---")

    if not CONTRACT_ADDRESS or not CONTRACT_ABI:
        print("\nERROR: Contract address or ABI is missing. Ensure deployment_info.json is valid.")
        print("Run deploy_visa_top_up.py first.")
        return

    if OWNER_PRIVATE_KEY == "YOUR_OWNER_PRIVATE_KEY_HERE" or \
       BACKEND_PRIVATE_KEY == "YOUR_BACKEND_PRIVATE_KEY_HERE" or \
       USER_FOR_TOPUP_ADDRESS == "0x________________________________________":
        print("\nERROR: Please replace placeholder private keys and user address in the script.")
        print("This script will not run correctly without valid account details.")
        return

    # 1. Connect to Ethereum node
    print("\nStep 1: Connecting to Ethereum Node...")
    w3 = Web3(Web3.HTTPProvider(ETH_NODE_URL))
    if not w3.is_connected():
        print(f"Failed to connect to Ethereum node at {ETH_NODE_URL}")
        return
    print(f"Successfully connected to Ethereum node. Chain ID: {w3.eth.chain_id}")

    # 2. Set up accounts
    print("\nStep 2: Setting up Accounts...")
    try:
        owner_account = w3.eth.account.from_key(OWNER_PRIVATE_KEY)
        backend_account = w3.eth.account.from_key(BACKEND_PRIVATE_KEY)
        print(f"Owner account: {owner_account.address}")
        print(f"Backend account: {backend_account.address}")
        if not Web3.is_address(USER_FOR_TOPUP_ADDRESS): # Basic checksum validation
             print(f"Error: USER_FOR_TOPUP_ADDRESS '{USER_FOR_TOPUP_ADDRESS}' is not a valid Ethereum address.")
             return
        print(f"User for top-up: {USER_FOR_TOPUP_ADDRESS}")

    except Exception as e:
        print(f"Error setting up accounts: {e}. Ensure private keys are correct and have '0x' prefix.")
        return

    # 3. Load the deployed contract
    print("\nStep 3: Loading Contract...")
    contract = load_contract(w3, CONTRACT_ADDRESS, CONTRACT_ABI)
    if not contract:
        return

    # --- Interaction Examples ---

    # 4. Set Authorized Backend (as Owner)
    print(f"\nStep 4: Setting Authorized Backend Address to {backend_account.address} (called by Owner)...")
    current_auth_backend = contract.functions.authorizedBackendAddress().call()
    print(f"Current authorized backend: {current_auth_backend}")
    if current_auth_backend != backend_account.address:
        set_backend_func = contract.functions.setAuthorizedBackend(backend_account.address)
        send_transaction(w3, set_backend_func, owner_account, GAS_LIMIT_INTERACTION, GAS_PRICE_GWEI_INTERACTION)
        time.sleep(2) # Give some time for state change to propagate if running on a live testnet
        new_auth_backend = contract.functions.authorizedBackendAddress().call()
        print(f"New authorized backend: {new_auth_backend}")
    else:
        print("Backend address is already set correctly.")

    # 5. Initiate Top-Up (as Authorized Backend)
    print("\nStep 5: Initiating Top-Up (called by Authorized Backend)...")
    top_up_amount = w3.to_wei(100, 'ether') # Example: 100 units (e.g., tokens, or currency smallest unit)
    visa_last_four = "1234"
    # Generate a unique topUpId (e.g., a hash or a random bytes32 string for testing)
    # For real systems, this ID should be carefully managed.
    top_up_id = os.urandom(32) # Generates random 32 bytes
    print(f"Generated topUpId: {top_up_id.hex()}")

    initiate_func = contract.functions.initiateTopUp(top_up_id, USER_FOR_TOPUP_ADDRESS, top_up_amount, visa_last_four)
    initiate_receipt = send_transaction(w3, initiate_func, backend_account, GAS_LIMIT_INTERACTION, GAS_PRICE_GWEI_INTERACTION)

    if initiate_receipt:
        print("Top-up initiated successfully (on-chain event emitted).")
        # Off-chain systems would now listen for this event and process the actual Visa top-up.

    # 6. Confirm Top-Up (as Authorized Backend)
    print("\nStep 6: Confirming Top-Up (called by Authorized Backend)...")
    # This would be called after the off-chain processing is complete.
    # We use the same top_up_id from the initiation step.
    success_status = True
    confirmation_message = "Top-up processed successfully by Visa gateway."

    confirm_func = contract.functions.confirmTopUp(top_up_id, success_status, confirmation_message)
    confirm_receipt = send_transaction(w3, confirm_func, backend_account, GAS_LIMIT_INTERACTION, GAS_PRICE_GWEI_INTERACTION)

    if confirm_receipt:
        print("Top-up confirmation processed successfully (on-chain event emitted).")

    # 7. Listen for/Query Past Events (Example: TopUpInitiated)
    print("\nStep 7: Querying Past 'TopUpInitiated' Events...")
    try:
        # Event filter might need to be adjusted based on how many blocks to scan
        # For local Ganache, fromBlock: 0 might be fine. For live networks, be more specific.
        event_filter = contract.events.TopUpInitiated.create_filter(
            fromBlock='earliest', # or a specific block number
            # argument_filters={'user': USER_FOR_TOPUP_ADDRESS} # Example filter by argument
        )
        past_events = event_filter.get_all_entries()
        if past_events:
            print(f"Found {len(past_events)} TopUpInitiated event(s):")
            for event in past_events:
                print(f"  - User: {event.args.user}, Amount: {w3.from_wei(event.args.amount, 'ether')}, "
                      f"VisaLastFour: {event.args.visaCardLastFourDigits}, TopUpID: {event.args.topUpId.hex()}, Block: {event.blockNumber}")
        else:
            print("No TopUpInitiated events found for the given filter.")

        # You can do the same for TopUpCompleted events
        event_filter_completed = contract.events.TopUpCompleted.create_filter(fromBlock='earliest')
        past_completed_events = event_filter_completed.get_all_entries()
        if past_completed_events:
            print(f"\nFound {len(past_completed_events)} TopUpCompleted event(s):")
            for event in past_completed_events:
                 print(f"  - TopUpID: {event.args.topUpId.hex()}, Success: {event.args.success}, Message: {event.args.message}, Block: {event.blockNumber}")
        else:
            print("No TopUpCompleted events found.")

    except Exception as e:
        print(f"Error querying events: {e}")


if __name__ == "__main__":
    # This is a placeholder script.
    # To actually run it:
    # 1. Ensure `deploy_visa_top_up.py` has been run and `deployment_info.json` exists.
    # 2. Ensure Ganache or another Ethereum node is running at ETH_NODE_URL.
    # 3. Replace placeholder private keys (OWNER_PRIVATE_KEY, BACKEND_PRIVATE_KEY) and USER_FOR_TOPUP_ADDRESS.
    #    The accounts corresponding to these keys must be available on your Ethereum node.
    #    The owner key should match the one used for deployment if you want setAuthorizedBackend to work without transferring ownership.
    # 4. Run `python interact_visa_top_up.py`
    main()
    print("\n--- Script Finished ---")
    print("Remember this is a placeholder; execution requires a configured environment and valid account keys.")
    print("Check transaction details on your Ethereum node/explorer if transactions were sent.")
